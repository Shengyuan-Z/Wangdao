## 智能指针

### unique_ptr

1. 禁止复制、赋值运算，这是独享所有权的智能指针；但可以接受右值（内部定义了具有移动语义的函数）

2. 占用大小为8B，有一个对象的地址

3. get()方法获取资源的地址

   ```C++
   //Returns a pointer to the managed object or nullptr if no object owned.
   pointer get() const noexcept;
   ```

4. reset()方法

   ```C++
   //Replaces the managed object.
   void reset( pointer ptr = pointer() ) noexcept;
   //ptr - pointer to a new object to manage
   ```

5. release()方法

   ```C++
   //Releases the ownership of the managed object if any. 
   pointer release() noexcept;
   ```

### shared_ptr

1. 引用计数采用的是源自操作，无线程安全的风险

2. 可以用另一个共享指针来拷贝构造或者赋值运算

3. 也可以用右值初始化，内部定义了具有移动语义的函数

4. 占用大小为16B，一个指针指向对象，另外部分用于计数，计数肯定是在heap上进行的，但具体实现不清楚

5. **循环引用问题**：导致内存泄漏

   + 通过将(两个强引用)变为(weak_ptr和shared_ptr联合使用)可以解决

6. get()方法

   ```C++
   T* get() const noexcept;
   ```

7. reset()方法

   ```C++
   void reset() noexcept; //deprived of the ownership;
   
   template< class Y >void reset( Y* ptr );//replace with ptr
   
   //Deleteot of our own is allowed
   template< class Y, class Deleter >void reset( Y* ptr, Deleter d );
   ```

   

### 智能指针的滥用

1. 将一个原生裸指针交给两个智能指针（同类或者不同类）托管，都会析构两次

```C++
void test0()
{
	Point * pt = new Point(1, 2);
	unique_ptr<Point> up(pt);
	unique_ptr<Point> up2(pt);//析构两次
}
void test1()
{
	Point * pt = new Point(1, 2);
	//执行复制或者赋值时，引用计数加1，这里两个指针都是用原生裸指针初始化的
    //use_count()都等于1，最后会析构两次
	shared_ptr<Point> up(pt);
	shared_ptr<Point> up2(pt);
	cout<<up.use_count()<<endl<<up2.use_count()<<endl;
}
```

2. 类内部无法获得指向this的智能指针

   + 原因是调用时会自动

   ```C++
   class Point
   {
   //......
   public:    
     	shared_ptr<Point> addPoint(Point * pt)
   	{
   		this->_x += pt->_x;
   		this->_y += pt->_y;
   		return shared_ptr<Point>(this); //会析构三次？？？理解？？？
           //因为返回时，相当于将一个原生裸指针交给了另一个智能指针
           
           //当public继承了std::enable_shared_from_this<Point>，后，可以使用下面方式，返回一个真正的共享指针，引用计数+1，最后也只会析构两次
   		//return shared_from_this();
   	}
   }
   void main()
   {
   	shared_ptr<Point> sp(new Point(1, 2));
   	shared_ptr<Point> sp2(new Point(11, 12));
   	shared_ptr<Point> sp3(sp->addPoint(sp2.get()));
   }
   
   ```

   

## 面向对象





## 编程

1. noexcept修饰符
   + noexcept可以用来修饰函数，在函数的后面加上noexcept，代表这个函数不会抛出异常，如果抛出异常程序就会终止。
   + 参考[《深入理解C++11》笔记--noexcept](https://blog.csdn.net/WizardtoH/article/details/80579131)

2. vim e + 文件名：可以在打开这个文件名，放buffer里
3. 查找 / + name , n next



## 其他

1. foo和bar就是外国人的张三、李四、王二麻子，只是一种随便的命名方式。

