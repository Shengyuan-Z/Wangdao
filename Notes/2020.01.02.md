## 强制转换

+ C风格：

  ```c++ 
  TYPE a 1 = （TYPE）EXPRESSION;
  ```

+ C++风格：

  1. static_cast < >的主要用法（安全性需保证）

     1. 用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。
     2. 把void指针转换成目标类型的指针，但不安全。
     3. 把任何类型的表达式转换成void类型。
     4. 用于类层次结构中基类和子类之间指针或引用的转换。进行上行转换（把子类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成子类指针或引用）时，由于没有动态类型检查，所以是不安全的。

  2. const_cast< >：该运算符用来修改类型的const属性。

     1. 常量指针被转化成非常量指针，并且仍然指向原来的对象
     2. 常量引用被转换成非常量引用，并且仍然指向原来的对象
     3. 常量对象被转换成非常量对象。

     ```C++
     const int number = 100;
     int * pInt = &number;//error
     int * pInt2 = const_cast<int *>(&number);
     ```

  3. dynamic_cast：该运算符主要用于基类和派生类间的转换，尤其是向下转型的用法中。

  4. reinterpret_cast：强大。用在任意指针（或引用）类型之间
     的转换，以及指针与足够大的整数类型之间的转换。

## 函数默认参数

+ 默认参数应从右至左逐渐定义。
+ 当调用函数时，只能从左开始匹配参数。

## inline函数

+ 目的：用会被编译器检查的 inline函数 代替不安全的 宏
+ 特点：
  + 编译器将使用函数的定义体来替代函数调用语句，这种替代行为发生在编译阶段而非程序运行阶段。
  + inline函数应在头文件中定义。
  + 空间换时间：内敛以代码膨胀为代价节省了函数调用的开销
    + 空间需求太大，即函数代码长、出现循环等其他复杂控制结构就放弃吧

## try catch

+ 执行过程：
  + 执行 try 块中的语句，如果执行的过程中没有异常拋出，那么执行完后就执行最后一个 catch 块后面的语句，所有 catch 块中的语句都不会被执行；
  + 如果 try 块执行的过程中拋出了异常，那么拋出异常后立即跳转到第一个“异常类型”和拋出的异常类型匹配的 catch 块中执行（称作异常被该 catch 块“捕获”），执行完后再跳转到最后一个 catch 块后面继续执行。

## 字符串

+ C风格： char*  以"\0"结尾

  + ``<string.h> ``或```<cstring> ```中
  + 程序员需要考虑字符数组大小的开辟，结尾空字符的处理，使用起来有诸多不便。

+ C++风格：std::string

  + 转换成C风格

    ```C++
    const char * c_str() const;// 返回一个C风格字符串
    const char * data() const;// c++11之后与c_str()效果一致
    //字符串的内容复制或写入既有的C风格字符串或字符数组内
    size_type copy(char* dest, size_type count, size_type pos = 0) const;
    ```

  + 存取：

    + [ ]操作符：不会检查
    + .at(n)：会检查是否越界
    + iterator可以遍历

  + 更多操作

## 程序内存分配

+ 程序内存分布

  + 内核态空间
  + 用户态空间
    + 堆
    + 栈
    + 代码区
    + 常量区：常量字符串
    + 全局静态区

+ 堆和栈的比较

  |                        | 堆                                                           | 栈                                                           |
  | :--------------------- | ------------------------------------------------------------ | :----------------------------------------------------------- |
  | 分配方式               | 动态                                                         | 静态                                                         |
  | 申请后系统的响应       | 操作系统有一个记录空闲内存地址的链表结构，可以用不同的算法分配。 | 只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 |
  | 生长方向和申请大小限制 | 堆是向高地址扩展的数据结构，是不连续的内存区域。<br />堆获得的空间比堆的大小受限于计算机系统中有效的虚拟内存较灵活，也比较大。 | 在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。<br />这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 |
  | 存储内容               | 一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。 | 在函数调用时，第一个进栈的是主函数的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。出栈相反。 |
  | 管理方式               | 手动                                                         | 自动                                                         |
  | 碎片                   | 有                                                           | 无                                                           |

  

## 类和对象

> 程序世界本质上只有两种东西：数据和逻辑。
>
> 数据天性喜静，构成了程序世界的本体和状态；逻辑天性好动，作用于数据，推动程序世界的演进和发展。

+ 类：一种抽象
  + class默认private， struct默认public



## 小点

+ C++设计风格：声明与定义不可混为一谈
+ 标准：可以理解为文档，实际上就是 功能/接口
  + 具体实现上可以不同，比如不同的编译器：
    + GCC
    + VC++  Microsoft
    + Clang/Clang++     LLVM（被Apple收购）   效率是GCC的5-10倍
    + Intel 商业性的
+ const数据成员一经初始化就变为只读



## 其他

+ SSH（Secure Shell） Protocol
  +  client-server model
  + listens on the standard Transmission Control Protocol (TCP) port 22
  + 参考 
    + https://searchsecurity.techtarget.com/definition/Secure-Shell
    + https://www.ssh.com/ssh/protocol
+ SSL(Secure Sockets Layer) Protocol
  
  + https://www.digicert.com/ssl/
+ 非对称密钥系统：
  + 它有公钥和私钥两把钥匙，加密使用公钥，解密使用私钥，然而从公钥几乎不可能推算出私钥，这样我可以把公钥随便扔在们外边，谁想给我发送加密信息都可以拿去用；加密完之后的数据，只有用我的私钥才能解开，其他人即使知道公钥也没有办法。这就非常有用了，最有用的用处之一就是交换前面的对称密钥，我先告诉你我的公钥，你把对称密钥用我的公钥加密发给我，我们就能安全交换对称密钥了。
    + 参考  https://www.zhihu.com/question/48927324/answer/113359990
  + 生成公钥
    + https://blog.csdn.net/shog808/article/details/76563136
  
  

