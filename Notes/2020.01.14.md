## 多态

### 定义

1. “一个接口，多种方法”

### 使用原因

1. 多态：实现代码复用 + 提高扩展性
   1. 编译时多态（静多态）：C++编译器根据传递给函数的参数和函数名决定具体要使用哪一个函数，又称为先期联编（early binding）。
      + eg 函数重载，运算符重载
   2. 运行时多态（动多态）：在程序运行时完成选择。编译器必须提供这么一套称为“动态联编”（dynamic binding）的机制，也叫晚期联编（late binding）。
      + **C++通过虚函数来实现动态联编**。

## 虚函数

### 概述

+ 定义：虚函数就是在基类中被声明为virtual，并在一个或多个派生类中被重新定义的成员函数。

+ 形式： 在成员函数的函数头前加 virtual
+ 如果一个基类的成员函数定义为虚函数，那么**它在所有派生类中也保持为虚函数**，即使在派生类中省略了virtual关键字，也仍然是虚函数。
+ virtual了private成员函数也会一直保持虚函数
+ 虚函数覆盖的格式要求：函数头、参数列表完全相同

### 虚函数的实现机制

1. 虚函数表
   + 当类中定义了一个虚函数后，会在该类创建的对象的存储布局的开始位置多一个虚函数指针（`vfptr`），在64位系统中占8字节。
   + 该虚函数指针指向了一张虚函数表，而该虚函数表就像一个数组，表中存放的就是各虚函数的入口地址。
   + 虚函数表在类对象创建后，不再修改（只读），故会存放在只读区。
2. 覆盖
   + 定义：当一个基类中设有虚函数，而一个派生类继承了该基类，并对虚函数进行的重定义
   
   + 实质：覆盖实际上是派生类的虚函数表中相应虚函数的入口地址被覆盖。//完全没了？
   
     ​																													 //对，指向了新函数的地址
   
   + **虚函数机制被激活的4个步骤**：（缺一不可）
     
     1. 基类定义虚函数，派生类重定义（覆盖）虚函数
        + 若非虚函数，无法实现多态，实现其他三个步骤调用的也是基类的函数，因为基类指针指向派生类，只能控制自己那部分内容，不能控制派生部分，即基类不能适应派生类。
     2. 创建派生类对象
     3. 基类的指针（或引用）指向派生类对象
     4. 基类指针调用虚函数
3. 不能被设为虚函数的函数
   + 非成员函数：和多态毫无关系
   + 静态成员函数：所有成员共享这一份代码，不能动态绑定
   + 内联成员函数：内联就是为了减少函数调用的代价，在代码中直接展开，与虚函数的使用将创建虚函数表相冲突。（给virtual函数加上inline也不起会作用，虽然可能编译器可以通过）
   + 构造函数：要有对象之后，才能实现多态，在对象创立完成之前的过程不能是虚函数。
   + 友元函数声明

### 虚函数访问

+ 指针访问（ 引用 相同）   就是最普通的用法，基类指针指向派生类对象
  + 使用指针访问非虚函数时，编译器根据指针本身的类型决定要调用哪个函数，而不是根据指针指向的对象类型
  + 使用指针访问虚函数时，编译器根据指针所指对象的类型决定要调用哪个函数(**动态联编**)，而与指针本身的类型无关。
+ 对象名调用：静态联编       base::display()
  + 对象类型是啥就是使用啥的
+ 成员函数内访问：动态联编
  + 在类内的成员函数中访问该类层次中的虚函数，采用**动态联编**，要使用`this`指针。

> 对象名调用成员 函数内访问的对比 eg

```C++
//基类和派生类都有virtual void display()方法
//在基类中有
	void func1()
	{
		this->display();//展现动态多态特性，func1会调用派生类的display()
	}
	void func2()
	{
		Base::display();//没有多态特性，始终是基类的display()
	}
```

+ 构造函数、析构函数中访问：静态联编
  
  + 即它们所调用的虚函数是自己类中定义的函数，如果在自己的类中没有实现该函数，则调用的是基类中的虚函数。
  + 但绝不会调用任何在派生类中重定义的虚函数。 派生类对象此时还没创建完成，不能调用其内容
  
  
  
  一个神奇的例子：关于默认参数传递

```C++
class A {
public:
	virtual 
    void func(int val = 1) {	cout << "A->" << val << endl;}

	virtual void test() {	func();		}
private:
	long _a;
};
class B
: public A {
public:
	virtual 
    void func(int val = 10) { cout << "B->" << val << endl; }
private:
	long _b;
};
int main(void)
{
	B b;
	A * p1 = (A*)&b;
	B * p2 = &b;
	p1->func();// 输出：B->1 函数头是基类的，函数体是派生类的？？可以这样理解
	p2->func();// 输出：B->10,虽然运行时会调用派生类虚函数,但对于传递的默认参数的值，只与指针的类型有关
	return 0;
}
```

### 纯虚函数

1. 作用：在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它自己不用实现，**它的实现留给该基类的派生类去做**。声明纯虚函数的目的在于，提供一个与派生类一致的接口。很好地体现了面向对象的开闭原则：对扩展开放，对修改关闭。

2. 格式：`virtual 返回类型 函数名(参数表) = 0；`

3. 抽象类：包含至少一个纯虚函数的类
   + 不能创建对象
   + 如果抽象类的派生类没有对所有的纯虚函数进行重定义，则该派生类也会成为抽象类。
   + 对一个类来说，如果只定义了protected型的构造函数而没有提供public构造函数，无论是在外部还是在派生类中作为其对象成员都不能创建该类的对象，但可以由其派生出新的类，这种能派生新类，却不能创建自己对象的类是另一种形式的抽象类。

### 虚析构函数 

+ 虽然构造函数不能被定义成虚函数，但析构函数可以定义为虚函数。
+ 一般来说，如果类中定义了虚函数，析构函数也应被定义为虚析构函数。不设成虚析构函数的话，用基类指针指向派生类，析构时只会调用基类的，发生了内存泄漏！派生类中多出来的部分不会释放！尤其是类内有申请的动态内存，需要清理和释放的时候。
+ 用基类指针new了一个派生类，都包含heap空间的成员，如果不把基类析构函数设为虚函数，delete该基类指针的时候仅会调用基类析构函数！！！
+ 和前面说的一样，如果基类的析构函数声明为虚的，派生类的析构函数也将自动成为虚析构函数，无论派生类析构函数声明中是否加virtual关键字。

### 重载、隐藏、覆盖的区分

+ 重载(overload)：发生在同一个类中，函数名称相同，但参数的类型、个数、顺序不同。
+ 覆盖(override)：发生在父子类中，同名**虚函数**，参数亦完全相同。（同名数据成员也有隐藏）
  + 可以父类重写的函数头后加上`override`，显式说明覆盖
+ 隐藏(oversee)：发生在父子类中，指的是在某些情况下，派生类中的函数屏蔽了基类中的同名函数。
  + 派生类中同**名**函数，不论参数、返回值如何，都只会调用派生类中的，基类中的完全被隐藏，除非用类作用域符显示调用
  + eg

```C++
//Base中有void print(int)，派生类和Base都有void print()
	d.print();//隐藏机制, 在基类与派生类之间，函数名相同
	//d.print(1); //error  派生类中根本看不到基类的相同名字的函数！！！
	d.Base::print();
```



## 编程

1. 面向对象设计原则之一：对扩展开放，对修改关闭
2. 将派生类转换为基类是不可以的，会导致可以访问不属于自己的内存
3. 基类初始化必须用基类构造函数

​	

## 小点

1. 指针类型会决定它++操作跨过的长度。
2. int main(int argc, char * argv[]) 的意义 (a.out使用时要加上参数)