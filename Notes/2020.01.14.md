## 多态

### 定义

1. “一个接口，多种方法”

### 使用原因

1. 多态：实现代码复用 + 提高扩展性
   1. 编译时多态（静多态）：C++编译器根据传递给函数的参数和函数名决定具体要使用哪一个函数，又称为先期联编（early binding）。
      + eg 函数重载，运算符重载
   2. 运行时多态（动多态）：在程序运行时完成选择。编译器必须提供这么一套称为“动态联编”（dynamic binding）的机制，也叫晚期联编（late binding）。
      + C++通过虚函数来实现动态联编。

## 虚函数

### 概述

+ 定义：虚函数就是在基类中被声明为virtual，并在一个或多个派生类中被重新定义的成员函数。

+ 形式： 在成员函数的函数头前加 virtual
+ 如果一个基类的成员函数定义为虚函数，那么它在所有派生类中也保持为虚函数，即使在派生类中省略了virtual关键字，也仍然是虚函数。
+ virtual了private成员函数也会如此
+ 重定义格式要求：
  - 与基类的虚函数有相同的参数个数；
  - 与基类的虚函数有相同的参数类型；
  - 与基类的虚函数有相同的返回类型。

### 实现机制

1. 虚函数表
   + 当类中定义了一个虚函数后，会在该类创建的对象的存储布局的开始位置多一个虚函数指针（`vfptr`），64位系统中占8字节。
   + 该虚函数指针指向了一张虚函数表，而该虚函数表就像一个数组，表中存放的就是各虚函数的入口地址。
2. 覆盖
   + 定义：当一个基类中设有虚函数，而一个派生类继承了该基类，并对虚函数进行了重定义
   + 实质：覆盖实际上是派生类的虚函数表中相应虚函数的入口地址被覆盖。
   + **虚函数机制是如何被激活的**：（缺一不可）
     1. 基类定义虚函数，派生类重定义（覆盖）虚函数
     2. 创建派生类对象
     3. 基类的指针指向派生类对象
     4. 基类指针调用虚函数
3. 不能被设为虚函数的函数
   + 非成员函数：和多态毫无关系
   + 静态成员函数：所有成员共享这一份代码，不能动态绑定
   + 内联成员函数：内联就是为了减少函数调用的代价，在代码中直接展开，与虚函数的使用将创建虚函数表相冲突。
   + 构造函数：虚函数要对不同类型的对象产生不同的动作，如果将构造函数定义成虚函数，那么对象都没有产生，怎么完成想要的动作呢
   + 友元函数声明

### 虚函数访问

+ 指针访问（ 引用 相同）
  + 使用指针访问非虚函数时，编译器根据指针本身的类型决定要调用哪个函数，而不是根据指针指向的对象类型
  + 使用指针访问虚函数时，编译器根据指针所指对象的类型决定要调用哪个函数(**动态联编**)，而与指针本身的类型无关。
+ 对象名调用：静态联编
  + 对象类型是啥就是使用啥的
+ 成员函数中访问：动态联编
  + 在类内的成员函数中访问该类层次中的虚函数，采用**动态联编**，要使用`this`指针。？？？
+ 构造函数、析构函数中访问：静态联编
  + 即它们所调用的虚函数是自己类中定义的函数，如果在自己的类中没有实现该函数，则调用的是基类中的虚函数。但绝不会调用任何在派生类中重定义的虚函数。 
+ 一个神奇的例子：对象名调用

```C++
class A {
public:
	virtual 
    void func(int val = 1) {	cout << "A->" << val << endl;}

	virtual void test() {	func();		}
private:
	long _a;
};
class B
: public A {
public:
	virtual 
    void func(int val = 10) { cout << "B->" << val << endl; }
private:
	long _b;
};
int main(void)
{
    B b;
	A * p1 = (A*)&b;
	B * p2 = &b;
	p1->func();// 输出：B->1 函数头是基类的，函数体是派生类的？？？
	p2->func();// 输出：B->10
	return 0;
}
```

### 纯虚函数

1. 作用：在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，**它的实现留给该基类的派生类去做**。

2. 格式：`virtual 返回类型 函数名(参数表) = 0；`

3. 抽象类：包含至少一个纯虚函数的类
   + 不能创建对象
   + 如果抽象类的派生类没有对所有的纯虚函数进行重定义，则该派生类也会成为抽象类。
4. **虚析构函数**要跟上！
   + 虽然构造函数不能被定义成虚函数，但析构函数可以定义为虚函数。
   + 一般来说，如果类中定义了虚函数，析构函数也应被定义为虚析构函数，尤其是类内有申请的动态内存，需要清理和释放的时候。
   + 用基类指针new了一个派生类，都包含heap空间的成员，如果不把基类析构函数设为虚函数，delete该基类指针的时候仅会调用基类析构函数！！！

### 重载、隐藏、覆盖的区分

+ 重载：发生在同一个类中，函数名称相同，但参数的类型、个数、顺序不同。

+ 覆盖：发生在父子类中，同名**虚函数**，参数亦完全相同。（同名数据成员也有隐藏）

+ 隐藏：发生在父子类中，指的是在某些情况下，派生类中的函数屏蔽了基类中的同名函数。
  + 如果派生类的函数与基类的函数名相同，但是参数不同。此时，不论有无virtual关键字。此时，基类函数会被隐藏。
  + 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏。





。。。

​	

## 小点

1. 指针类型会决定它++操作跨过的长度。